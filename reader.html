<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>高清漫画阅读器</title>
    
    <!-- iOS PWA 适配 -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="高清漫画">
    <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/lucide-react/lucide/main/icons/book-open.png">

    <!-- 外部库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <!-- Firebase Compat (可选) -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        
        :root {
            --sat: env(safe-area-inset-top);
            --sar: env(safe-area-inset-right);
            --sab: env(safe-area-inset-bottom);
            --sal: env(safe-area-inset-left);
        }

        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #050505; 
            color: white; 
            margin: 0; 
            overscroll-behavior: none; 
            -webkit-tap-highlight-color: transparent;
            user-select: none; 
            -webkit-user-select: none;
        }

        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        .drag-handle-line { width: 2px; height: 24px; background-color: rgba(255,255,255,0.3); border-radius: 99px; }
        
        .shelf-nav { padding-top: calc(1rem + var(--sat)); }
        
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .animate-fade-in { animation: fadeIn 0.3s ease-out forwards; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // --- CSS 变量定义 (修复 ReferenceError) ---
        const scrollBarStyle = `
            .no-scrollbar::-webkit-scrollbar { display: none; }
            .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        `;

        // --- 本地数据库 (IndexedDB) 配置 ---
        const DB_NAME = 'ComicReaderDB_v10';
        const STORE_FILES = 'pdf_files';
        const STORE_META = 'book_metadata';
        const STORE_SERIES = 'series_metadata';

        const openDB = () => {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 3);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_FILES)) db.createObjectStore(STORE_FILES);
                    if (!db.objectStoreNames.contains(STORE_META)) db.createObjectStore(STORE_META);
                    if (!db.objectStoreNames.contains(STORE_SERIES)) db.createObjectStore(STORE_SERIES);
                };
                request.onsuccess = (e) => resolve(e.target.result);
                request.onerror = (e) => reject(e.target.error);
            });
        };

        const saveToLocal = async (storeName, id, data) => {
            const dbRef = await openDB();
            return new Promise((resolve, reject) => {
                const tx = dbRef.transaction(storeName, 'readwrite');
                tx.objectStore(storeName).put(data, id);
                tx.oncomplete = () => resolve();
                tx.onerror = (e) => reject(e.target.error);
            });
        };

        const getFromLocal = async (storeName, id) => {
            const dbRef = await openDB();
            return new Promise((resolve) => {
                const tx = dbRef.transaction(storeName, 'readonly');
                const req = tx.objectStore(storeName).get(id);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => resolve(null);
            });
        };

        const getAllFromLocal = async (storeName) => {
            const dbRef = await openDB();
            return new Promise((resolve) => {
                const tx = dbRef.transaction(storeName, 'readonly');
                const req = tx.objectStore(storeName).getAll();
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => resolve([]);
            });
        };

        const deleteFromLocal = async (id) => {
            const dbRef = await openDB();
            const tx = dbRef.transaction([STORE_FILES, STORE_META], 'readwrite');
            tx.objectStore(STORE_FILES).delete(id);
            tx.objectStore(STORE_META).delete(id);
            return new Promise(r => tx.oncomplete = r);
        };

        // --- 主程序 App ---
        function App() {
            // 基础状态
            const [books, setBooks] = useState([]);
            const [series, setSeries] = useState([]);
            const [view, setView] = useState('shelf'); 
            const [isSelectMode, setIsSelectMode] = useState(false);
            const [selectedIds, setSelectedIds] = useState([]);
            const [sortMode, setSortMode] = useState('time');
            const [loading, setLoading] = useState(false);
            const [progress, setProgress] = useState(0);

            // 阅读器深度状态
            const [currentBookId, setCurrentBookId] = useState(null);
            const [pdfDoc, setPdfDoc] = useState(null);
            const [thumbnails, setThumbnails] = useState([]);
            const [highResCache, setHighResCache] = useState({});
            const [layout, setLayout] = useState([]);
            const [startIndex, setStartIndex] = useState(0);
            
            // 交互提示状态
            const [showBackHint, setShowBackHint] = useState(false);
            const [showNavHint, setShowNavHint] = useState(false);
            const [isNavOpen, setIsNavOpen] = useState(false);
            const [readerContextMenu, setReaderContextMenu] = useState(null);

            const scrollContainerRef = useRef(null);
            const pageRefs = useRef([]);
            const swipeStartX = useRef(null);
            const groupGestureRef = useRef({ startY: null, groupIdx: null });

            useEffect(() => {
                window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                refreshLibrary();
            }, []);

            const refreshLibrary = async () => {
                const b = await getAllFromLocal(STORE_META);
                const s = await getAllFromLocal(STORE_SERIES);
                setBooks(b);
                setSeries(s);
            };

            const renderPage = async (pdf, pageNum, scale = 0.5) => {
                try {
                    const page = await pdf.getPage(pageNum);
                    const viewport = page.getViewport({ scale });
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d', { alpha: false });
                    canvas.height = viewport.height; canvas.width = viewport.width;
                    await page.render({ canvasContext: ctx, viewport }).promise;
                    const url = canvas.toDataURL('image/jpeg', scale > 1 ? 0.85 : 0.6);
                    canvas.width = 0; canvas.height = 0;
                    return url;
                } catch (e) { return null; }
            };

            const handleImport = async (e) => {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;
                setLoading(true);
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    setProgress(Math.round(((i + 1) / files.length) * 100));
                    try {
                        const buffer = await file.arrayBuffer();
                        const bookId = crypto.randomUUID ? crypto.randomUUID() : `b_${Date.now()}_${i}`;
                        await saveToLocal(STORE_FILES, bookId, buffer);
                        const pdf = await window.pdfjsLib.getDocument({ data: new Uint8Array(buffer) }).promise;
                        const cover = await renderPage(pdf, 1, 0.4);
                        const initialLayout = Array.from({ length: pdf.numPages }, (_, k) => [k]);
                        const meta = {
                            id: bookId,
                            title: file.name.replace('.pdf', ''),
                            totalPages: pdf.numPages,
                            coverUrl: cover,
                            lastReadIndex: 0,
                            layout: JSON.stringify(initialLayout),
                            createdAt: { seconds: Date.now() / 1000 }
                        };
                        await saveToLocal(STORE_META, bookId, meta);
                        await pdf.destroy();
                    } catch (err) { console.error("Local Import Error:", err); }
                }
                await refreshLibrary();
                setLoading(false);
                e.target.value = '';
            };

            const openFromShelf = async (book) => {
                setLoading(true); setThumbnails([]); setHighResCache({});
                try {
                    const data = await getFromLocal(STORE_FILES, book.id);
                    if (data) {
                        const pdf = await window.pdfjsLib.getDocument({ data: new Uint8Array(data) }).promise;
                        setPdfDoc(pdf);
                        setLayout(JSON.parse(book.layout));
                        setCurrentBookId(book.id);
                        setStartIndex(book.lastReadIndex || 0);
                        const allT = [];
                        for(let i=1; i<=pdf.numPages; i++) { allT.push(await renderPage(pdf, i, 0.25)); }
                        setThumbnails(allT); setView('reader');
                    }
                } catch(e) { console.error(e); } finally { setLoading(false); }
            };

            useEffect(() => {
                if (view === 'reader' && pdfDoc && thumbnails.length > 0) {
                    const pages = [startIndex, startIndex + 1, startIndex - 1];
                    pages.forEach(async (idx) => {
                        if (idx >= 0 && idx < thumbnails.length && !highResCache[idx]) {
                            const hr = await renderPage(pdfDoc, idx + 1, 1.8);
                            if (hr) setHighResCache(prev => ({ ...prev, [idx]: hr }));
                        }
                    });
                }
            }, [view, pdfDoc, startIndex, thumbnails.length]);

            const saveMetaToLocal = async (id, updateData) => {
                const meta = await getFromLocal(STORE_META, id);
                if (meta) await saveToLocal(STORE_META, id, { ...meta, ...updateData });
            };

            const handleMerge = async (idx, dir) => {
                let newL = [...layout];
                let groupA = newL.find(g => g.includes(idx));
                let groupB = newL.find(g => g.includes(idx + dir));
                if (!groupA || !groupB || groupA === groupB) return;
                const merged = Array.from(new Set([...groupA, ...groupB])).sort((a, b) => a - b);
                const filtered = newL.filter(g => g !== groupA && g !== groupB);
                const insertPos = Math.min(newL.indexOf(groupA), newL.indexOf(groupB));
                filtered.splice(insertPos, 0, merged);
                setLayout(filtered);
                setReaderContextMenu(null);
                saveMetaToLocal(currentBookId, { layout: JSON.stringify(filtered) });
            };

            const handleSwapOrder = async (groupIdx) => {
                const newL = [...layout];
                newL[groupIdx] = [...newL[groupIdx]].reverse();
                setLayout(newL);
                saveMetaToLocal(currentBookId, { layout: JSON.stringify(newL) });
            };

            const handleSplitGroup = async (groupIdx) => {
                const newL = [...layout];
                const group = newL[groupIdx];
                if (!group || group.length <= 1) return;
                const split = group.map(p => [p]).sort((a,b)=>a[0]-b[0]);
                newL.splice(groupIdx, 1, ...split);
                setLayout(newL);
                saveMetaToLocal(currentBookId, { layout: JSON.stringify(newL) });
            };

            const exitReader = async () => {
                if (currentBookId) await saveMetaToLocal(currentBookId, { lastReadIndex: startIndex });
                if (pdfDoc) await pdfDoc.destroy();
                setPdfDoc(null); setView('shelf'); refreshLibrary();
            };

            const displayItems = useMemo(() => {
                return [...books].sort((a, b) => sortMode === 'name' ? a.title.localeCompare(b.title) : (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0));
            }, [books, sortMode]);

            return (
                <div className="min-h-screen bg-[#050505] text-white">
                    <style>{scrollBarStyle}</style>
                    
                    {view === 'shelf' ? (
                        <div className="animate-fade-in">
                            <nav className="sticky top-0 z-40 bg-zinc-950/80 backdrop-blur-2xl border-b border-white/5 shelf-nav px-6 pb-4 flex justify-between items-center">
                                <div className="flex items-center gap-4">
                                    <div className="w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center font-black text-[10px]">LOCAL</div>
                                    <h1 className="text-sm font-black uppercase tracking-widest">Comic Shelf</h1>
                                </div>
                                <div className="flex items-center gap-3">
                                    <button onClick={() => { setIsSelectMode(!isSelectMode); setSelectedIds([]); }} className={`h-10 px-4 rounded-full text-[10px] font-black uppercase transition-all ${isSelectMode ? 'bg-blue-600 shadow-lg' : 'bg-zinc-900 border border-white/10 text-zinc-400'}`}>
                                        {isSelectMode ? 'Done' : 'Select'}
                                    </button>
                                    <label className="h-10 px-5 rounded-full flex items-center justify-center font-bold text-[10px] uppercase cursor-pointer bg-white text-black active:scale-95 shadow-xl transition-all">
                                        Import PDF
                                        <input type="file" multiple accept=".pdf" className="hidden" onChange={handleImport} />
                                    </label>
                                </div>
                            </nav>
                            <main className="max-w-screen-xl mx-auto p-6 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-8 pb-32">
                                {displayItems.map(item => {
                                    const selected = selectedIds.includes(item.id);
                                    return (
                                        <div key={item.id} className="group cursor-pointer active:scale-95 transition-all" onClick={() => {
                                            if (isSelectMode) setSelectedIds(p => p.includes(item.id) ? p.filter(i=>i!==item.id) : [...p, item.id]);
                                            else openFromShelf(item);
                                        }}>
                                            <div className={`relative aspect-[3/4] mb-4 transition-all duration-500 ${selected ? 'scale-90' : 'group-hover:scale-105'}`}>
                                                <div className={`w-full h-full rounded-2xl overflow-hidden bg-zinc-900 border ${selected ? 'border-blue-500 ring-4 ring-blue-500/30' : 'border-white/5'} shadow-2xl`}>
                                                    {item.coverUrl ? <img src={item.coverUrl} className="w-full h-full object-cover" /> : <div className="w-full h-full flex items-center justify-center opacity-10 font-bold text-xs uppercase">No Cover</div>}
                                                </div>
                                                {isSelectMode && (
                                                    <div className="absolute top-3 left-3 w-6 h-6 rounded-full border-2 border-white/50 bg-black/20 flex items-center justify-center transition-all">
                                                        {selected && <div className="w-3 h-3 bg-blue-500 rounded-full" />}
                                                    </div>
                                                )}
                                            </div>
                                            <h3 className="font-bold text-xs truncate text-zinc-300 px-1">{item.title}</h3>
                                        </div>
                                    );
                                })}
                            </main>
                        </div>
                    ) : (
                        <div className="fixed inset-0 z-[100] bg-black flex flex-row overflow-hidden animate-fade-in">
                            {isNavOpen && (
                                <div className="h-full w-32 flex-shrink-0 z-[150] bg-zinc-950/40 backdrop-blur-3xl border-r border-white/5 flex flex-col no-scrollbar">
                                    <div className="w-full h-16 flex items-center justify-center cursor-ew-resize" 
                                         onMouseDown={e => swipeStartX.current = e.clientX}
                                         onMouseMove={e => { if(e.buttons === 1 && swipeStartX.current - e.clientX > 40) setIsNavOpen(false); }}
                                         onTouchStart={e => swipeStartX.current = e.touches[0].clientX}
                                         onTouchMove={e => { if(swipeStartX.current - e.touches[0].clientX > 40) setIsNavOpen(false); }}>
                                        <div className="flex gap-1.5 opacity-30"><div className="drag-handle-line"></div><div className="drag-handle-line"></div><div className="drag-handle-line"></div></div>
                                    </div>
                                    <div className="flex-1 overflow-y-auto px-4 pb-12 space-y-5 no-scrollbar">
                                        {thumbnails.map((thumb, idx) => (
                                            <div key={idx} onClick={() => pageRefs.current[idx]?.scrollIntoView({ behavior: 'auto' })} className={`relative aspect-[3/4] rounded-xl overflow-hidden border-2 transition-all ${startIndex === idx ? 'border-blue-500 shadow-lg scale-105' : 'border-white/5'}`}>
                                                <img src={thumb} className="w-full h-full object-cover" />
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            <div className={`flex-1 relative h-full overflow-hidden transition-all duration-500 ${isNavOpen ? 'pl-6' : 'pl-0'}`} onClick={() => setReaderContextMenu(null)}>
                                <div className="fixed top-0 left-0 w-32 h-32 z-[130] cursor-pointer" onDoubleClick={exitReader} onClick={() => { setShowBackHint(true); setTimeout(()=>setShowBackHint(false), 2000); }}>
                                    {showBackHint && <div className="absolute top-10 left-10 bg-black/60 p-4 rounded-2xl border border-white/10 text-[10px] font-black uppercase tracking-tighter shadow-2xl">Double Tap Exit</div>}
                                </div>
                                <div className="fixed bottom-0 left-0 w-32 h-32 z-[130] cursor-pointer" onDoubleClick={() => setIsNavOpen(!isNavOpen)} onClick={() => { setShowNavHint(true); setTimeout(()=>setShowNavHint(false), 2000); }}>
                                    {showNavHint && <div className="absolute bottom-10 left-10 bg-black/60 p-4 rounded-2xl border border-white/10 text-[10px] font-black uppercase tracking-tighter shadow-2xl">Double Tap Nav</div>}
                                </div>

                                <div className="w-full h-full overflow-y-auto no-scrollbar pb-32" 
                                     onScroll={e => {
                                        const rects = e.target.firstChild.children;
                                        for(let i=0; i<rects.length; i++) {
                                            const box = rects[i].getBoundingClientRect();
                                            if(box.top >= 0 && box.top < 400) { if(layout[i]) setStartIndex(layout[i][0]); break; }
                                        }
                                     }} ref={scrollContainerRef}>
                                    <div className="flex flex-col items-center gap-0 max-w-4xl mx-auto">
                                        {layout.map((group, groupIdx) => (
                                            <div key={groupIdx} 
                                                 className={`w-full flex justify-center gap-0 ${group.length > 1 ? 'flex-row' : 'flex-col items-center'}`}
                                                 onClick={(e) => { if (group.length > 1) { e.stopPropagation(); handleSwapOrder(groupIdx); } }}
                                                 onMouseDown={e => { groupGestureRef.current = { startY: e.clientY, groupIdx }; }}
                                                 onMouseMove={e => {
                                                     const { startY, groupIdx: gIdx } = groupGestureRef.current;
                                                     if (startY !== null && gIdx === groupIdx && group.length > 1 && Math.abs(e.clientY - startY) > 80) {
                                                         handleSplitGroup(gIdx);
                                                         groupGestureRef.current = { startY: null, groupIdx: null };
                                                     }
                                                 }}
                                                 onTouchStart={e => { groupGestureRef.current = { startY: e.touches[0].clientY, groupIdx }; }}
                                                 onTouchMove={e => {
                                                     const { startY, groupIdx: gIdx } = groupGestureRef.current;
                                                     if (startY !== null && gIdx === groupIdx && group.length > 1 && Math.abs(e.touches[0].clientY - startY) > 80) {
                                                         handleSplitGroup(gIdx);
                                                         groupGestureRef.current = { startY: null, groupIdx: null };
                                                     }
                                                 }}
                                                 onMouseUp={() => { groupGestureRef.current = { startY: null, groupIdx: null }; }}
                                                 onTouchEnd={() => { groupGestureRef.current = { startY: null, groupIdx: null }; }}>
                                                {group.map(pIdx => (
                                                    <div key={pIdx} ref={el => pageRefs.current[pIdx] = el} className="relative w-full overflow-hidden" onContextMenu={e => { e.preventDefault(); e.stopPropagation(); setReaderContextMenu({ x: e.clientX, y: e.clientY, index: pIdx }); }}>
                                                        <img src={highResCache[pIdx] || thumbnails[pIdx]} className={`w-full h-auto object-contain transition-all duration-700 ${highResCache[pIdx] ? 'blur-0 opacity-100' : 'blur-lg opacity-40'}`} />
                                                        <div className="absolute top-4 left-4 bg-black/40 px-2 py-0.5 rounded text-[8px] font-bold">P.{pIdx+1}</div>
                                                    </div>
                                                ))}
                                            </div>
                                        ))}
                                    </div>
                                </div>

                                {readerContextMenu && (
                                    <div className="fixed z-[200] bg-zinc-900 border border-white/10 rounded-2xl p-2 w-44 shadow-2xl" style={{ left: Math.min(readerContextMenu.x, window.innerWidth - 180), top: Math.min(readerContextMenu.y, window.innerHeight - 150) }}>
                                        <button onClick={() => handleMerge(readerContextMenu.index, 1)} className="w-full text-left px-4 py-3 text-xs font-bold hover:bg-blue-600 rounded-xl">与后页合并</button>
                                        <button onClick={() => handleMerge(readerContextMenu.index, -1)} className="w-full text-left px-4 py-3 text-xs font-bold hover:bg-blue-600 rounded-xl">与前页合并</button>
                                        <button onClick={() => handleSplitGroup(layout.findIndex(g=>g.includes(readerContextMenu.index)))} className="w-full text-left px-4 py-3 text-xs font-bold text-red-400 hover:bg-red-600/20 rounded-xl border-t border-white/5 mt-1 text-center">解开拼合</button>
                                    </div>
                                )}
                            </div>
                        </div>
                    )}

                    {isSelectMode && selectedIds.length > 0 && (
                        <div className="fixed bottom-10 left-1/2 -translate-x-1/2 z-[100] w-full max-w-md bg-zinc-900/90 backdrop-blur-xl border border-white/10 rounded-full p-4 flex justify-between items-center shadow-2xl">
                            <span className="ml-4 font-black text-xs uppercase tracking-tighter">{selectedIds.length} SELECTED</span>
                            <div className="flex gap-2">
                                <button onClick={() => {
                                    if(confirm(`Confirm Delete ${selectedIds.length} items?`)) {
                                        selectedIds.forEach(id => deleteFromLocal(id));
                                        setSelectedIds([]); setIsSelectMode(false); refreshLibrary();
                                    }
                                }} className="h-10 px-6 bg-red-600 text-white rounded-full font-bold text-xs uppercase">Delete</button>
                            </div>
                        </div>
                    )}

                    {loading && (
                        <div className="fixed bottom-10 right-10 z-[250] bg-blue-600 text-white p-6 rounded-3xl shadow-2xl flex flex-col gap-2 min-w-[220px]">
                            <div className="flex justify-between text-[10px] font-black uppercase tracking-widest">
                                <span>Importing...</span>
                                <span>{progress}%</span>
                            </div>
                            <div className="h-1.5 bg-black/20 rounded-full overflow-hidden">
                                <div className="h-full bg-white transition-all duration-300" style={{ width: `${progress}%` }} />
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>